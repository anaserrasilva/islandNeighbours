threshold=73
output=list()
verbose=TRUE
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
islands = output
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
islands = output
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree<-testTrees
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
islands = output
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
islands
#'
#' @references Maddison, D. R. (1991) \href{https://doi.org/10.1093/sysbio/40.3.315}{The discovery and importance of multiple islands of most-parsimonious trees}. \emph{Syst. Zool.}, 40:315-328
#'
#' @import ape
#' phangorn
#' phytools
#' thacklr
#' Quartet
#'
#' @export
xQDislands <- function(tree, threshold, output = list(), verbose = TRUE){
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
islands = output
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
#to call recursive function
t2 <- tree
if (length(t2) == 1) {
islands[[int(counter+1)]] <- t2
return(islands)
}
if (length(ape::unique.multiPhylo(c(t2,t), use.edge.length = F)) != length(t2)) {
xQDislands(tree, threshold, islands)
}
else {
return(islands)
}
}
isles<-xQDislands(testTrees, 73, output=list())
#'
#' @references Maddison, D. R. (1991) \href{https://doi.org/10.1093/sysbio/40.3.315}{The discovery and importance of multiple islands of most-parsimonious trees}. \emph{Syst. Zool.}, 40:315-328
#'
#' @import ape
#' phangorn
#' phytools
#' thacklr
#' Quartet
#'
#' @export
xQDislands <- function(tree, threshold, output = list(), verbose = TRUE){
tree <- ape::unroot.multiPhylo(tree)
tree <- ape::unique.multiPhylo(tree)
l <- length(tree)
x <- threshold
islands = output
m <- Quartet::TQDist(tree)
rownames(m) <- c(1:l)
test<-sort(unique(as.vector(m[1,])))
counter = length(islands) + 1
#adding property, equivalent of colour in graph-based clustering approaches
p <- rep(c('a'), times = l)
p[1] <- 'b'
s <- m[m[1,] <= x,]
p[c( as.numeric(rownames(s)))] <- 'b'
for (k in 2:l) {
if (verbose == TRUE) {
print(paste("At tree", k, sep=' '))
}
if (p[k] == 'b') {
s <- m[m[k,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
#recover trees within threshold missed in first go around
for (i in 1:l) {
if (p[i] == 'b') {
s <- m[m[i,] <= x,]
p[c(as.numeric(rownames(s)))] <- 'b'
}
r <- c(which(p == 'b'))
t <- tree[c(as.numeric(r))]
}
}
if (length(t) != 1) {
t <- ape::unique.multiPhylo(thacklr::as.multiPhylo.list(t), use.edge.length = F)
}
islands[[counter]] <- t
#counter = counter + 1
if (length(t) != l) {
tree <- tree[-c(as.numeric(r))]
}
#to call recursive function
t2 <- tree
if (length(t2) == 1) {
islands[[counter+1]] <- t2
return(islands)
}
if (length(ape::unique.multiPhylo(c(t2,t), use.edge.length = F)) != length(t2)) {
xQDislands(tree, threshold, islands)
}
else {
return(islands)
}
}
isles<-xQDislands(testTrees, 73, output=list())
isles
library(devtools)
library(roxygen2)
setwd("D:\\Documents\\GitHub\\islandNeighbours\\islandNeighbours")
document()
document()
check()
document()
check()
document()
check()
document()
check()
build()
quit()
